import pandas as pd
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.linear_model import LinearRegression
# 分类特征和数值特征列表
categorical_features = ['Direction', 'District', 'Elevator', 'Layout', 'Region', 'Renovation']
num_features = ['Size', 'Year']
# 加载或定义训练好的模型、编码器和标准化器
# encoder = OneHotEncoder()  # 已训练好的编码器
# scaler = StandardScaler()  # 已训练好的标准化器
# model = LinearRegression()  # 已训练好的线性回归模型

def predict_price(input_data):
    # 将用户输入的数据转换为DataFrame
    input_df = pd.DataFrame([input_data])

    # 对分类特征进行独热编码
    encoded_input = encoder.transform(input_df[categorical_features])
    encoded_input_df = pd.DataFrame(encoded_input, columns=encoder.get_feature_names_out())

    # 合并编码后的数据和原始DataFrame
    input_df = pd.concat([input_df.reset_index(drop=True), encoded_input_df], axis=1)

    # 删除原始的分类特征列
    input_df.drop(columns=categorical_features, inplace=True)

    # 标准化数值特征
    input_df[num_features] = scaler.transform(input_df[num_features])

    # 使用训练好的模型预测房价
    return model.predict(input_df)[0]

# 示例用户输入数据
input_data = {
    'Direction': '南北',
    'District': '东单',
    'Elevator': '无电梯',
    'Floor': '6',
    'Layout': '2室1厅',
    'Region': '东城',
    'Renovation': '精装',
    'Size': 60,
    'Year': 1988
}


                                                              五个方法
1. pivot_table：透视表操作
方法： 使用pivot_table方法可以根据一个或多个键对数据进行透视，类似于Excel中的透视表功能。

示例代码： 创建一个透视表，计算不同产品在不同月份的销售额。
import pandas as pd

# 创建一个DataFrame
data = {
    'Month': ['Jan', 'Jan', 'Feb', 'Feb', 'Jan', 'Feb'],
    'Product': ['A', 'B', 'A', 'B', 'A', 'B'],
    'Sales': [100, 200, 150, 250, 120, 220]
}
df = pd.DataFrame(data)

# 创建透视表
pivot_df = df.pivot_table(index='Month', columns='Product', values='Sales', aggfunc='sum')
print(pivot_df)
输出
Product    A    B
Month            
Feb      150  250
Jan      220  200
2. cut：数据分箱操作
方法： 使用cut方法将连续的数值数据分成离散的区间（箱子）。

示例代码： 对一个数据列进行分箱操作，并计算每个箱子中的数据数量。
import pandas as pd

# 创建一个DataFrame
data = {
    'Value': [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
}
df = pd.DataFrame(data)

# 数据分箱
bins = [0, 30, 60, 100]
labels = ['Low', 'Medium', 'High']
df['Bins'] = pd.cut(df['Value'], bins=bins, labels=labels, right=True)

# 计算每个箱子中的数据数量
bin_counts = df['Bins'].value_counts()
print(bin_counts)
输出
Low       3
Medium    4
High      3
Name: Bins, dtype: int64

3. applymap：应用函数到数据框的每个元素
方法： 使用applymap方法将函数应用到数据框的每个元素。

示例代码： 将一个数据框中的所有元素转换为小写。
import pandas as pd

# 创建一个DataFrame
data = {
    'A': ['Apple', 'Banana', 'Orange'],
    'B': ['Cat', 'Dog', 'Elephant']
}
df = pd.DataFrame(data)

# 应用函数到每个元素
df_lower = df.applymap(lambda x: x.lower())
print(df_lower)
输出
        A         B
0   apple       cat
1  banana       dog
2  orange  elephant
4. pd.to_datetime：日期时间转换
方法： 使用pd.to_datetime方法将字符串或数值转换为日期时间格式。

示例代码： 将一个包含日期字符串的列转换为日期时间格式，并提取出年份。
import pandas as pd

# 创建一个DataFrame
data = {
    'A': ['Apple', 'Banana', 'Orange'],
    'B': ['Cat', 'Dog', 'Elephant']
}
df = pd.DataFrame(data)

# 使用DataFrame.apply和Series.map来转换为小写
df_lower = df.apply(lambda x: x.map(lambda y: y.lower() if isinstance(y, str) else y))
print(df_lower)
输出
        Date  Year
0 2023-01-01  2023
1 2024-02-15  2024
2 2025-03-30  2025
5. stack 和 unstack：数据堆叠与解堆操作
方法： 使用stack方法将数据框的列“堆叠”为多层索引的行，使用unstack方法将多层索引的行“解堆”为列。

示例代码： 创建一个多层索引的数据框，并进行堆叠与解堆操作。
import pandas as pd

# 创建一个DataFrame
data = {
    'A': [1, 2, 3],
    'B': [4, 5, 6],
    'C': [7, 8, 9]
}
df = pd.DataFrame(data, index=['X', 'Y', 'Z'])

# 将列堆叠为多层索引的行
stacked_df = df.stack()
print(stacked_df)

# 解堆多层索引的行为列
unstacked_df = stacked_df.unstack()
print(unstacked_df)
输出
X  A    1
   B    4
   C    7
Y  A    2
   B    5
   C    8
Z  A    3
   B    6
   C    9
dtype: int64

   A  B  C
X  1  4  7
Y  2  5  8
Z  3  6  9
